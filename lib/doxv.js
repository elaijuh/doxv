var fs = require('fs');
var path = require('path');
var jade = require('jade');
var md = require('marked');
var dox = require('dox');
var ncp = require('ncp').ncp;

module.exports = {
	version: require('../package.json').version,
	process: process
};

/**
 * prepare the output documents path
 * @param  {String} output output path to be processed
 * @return {String} resolved output path
 * @api private
 */
function prepareOutputPath(output) {
	output = output ? path.resolve(output) : path.resolve('doc');
	createDirIfNotExist(output);
	var assets = path.join(output, 'assets');
	createDirIfNotExist(assets);
	var custom = path.join(assets, 'custom');
	createDirIfNotExist(custom);

	return output;
}
/**
 * creates a directory if it doesnt exist. This will not create directories recursively.
 * @param {String} dir the path to the directory to create
 * @api private
 */
function createDirIfNotExist(dir) {
	if (!fs.existsSync(dir)) {
		fs.mkdirSync(dir, '0777');
	}
}

/**
 * list all the js files under the directories recursively
 * @param  {String} input base directory to search
 * @param  {String} exclude directories to be excluded
 * @param  {Array} list store final js file list
 * @return {Array} interim files list
 * @api private
 * @example
 *  var list = [];
 *  walk('./src', list); // all the js files under ./src will be stored in list
 */
function walk(input, exclude, list) {
	var res = [];
	var files = fs.readdirSync(input);
	files.forEach(function (file) {
		var stat = fs.statSync(path.join(input, file));
		if (stat.isDirectory() && exclude.indexOf(file) === -1) {
			list.concat(walk(path.join(input, file), exclude, list));
		} else if (/.js$/.test(file)) {
			list.push(path.join(input, file));
		}
	});

	return res;
}

/**
 * get package.json
 * @param  {String} input current path
 * @return {Object}      package.json
 */
function getPackage(input) {
	var pkg;

	try {
		pkg = require(path.resolve(input, 'package.json'));
	} catch (e) {
		console.error('error: package.json is not found');
	}

	return pkg;
}

/**
 * get README.md
 * @param  {String} input current path
 * @return {Object}       object generated by marked
 */
function getReadme(input) {
	var content;
	try {
		content = fs.readFileSync(path.join(input, 'README.md'), 'utf8');
	} catch(e) {
		content = '###README is not found';
	}

	return md(content);
}

/**
 * get source js under current path recursively
 * @param  {String} input root path for source js
 * @return {Array}      all source js
 */
function getDocs(input) {
	var docs = {};
	var docPath = path.join(input, 'doc');
	if (fs.existsSync(docPath)) {
		fs.readdirSync(docPath).filter(function (fileName) {
			return /\.md$/.test(fileName); // filter .md files
		}).forEach(function (fileName) {
			var fil = /^(.*)\.md$/.exec(fileName)[1]; // file name w/o ext
			var content = fs.readFileSync(path.join(docPath, fileName), 'utf8');
			docs[fil] = md(content);
		});
	}

	return docs;
}

/**
 * parse all source js by marked
 * @param  {String} basePath root bath for source js
 * @param  {String} files    array of source js files
 * @return {Object}          object contains all marked parsed js
 */
function getApis(basePath, files) {
	var apis = {};
	var basename, comments, dirs, content;
	files.forEach(function (file) {
		content = fs.readFileSync(file,'utf8');
		basename = path.basename(file, '.js');
		comments = dox.parseComments(content, {skipSingleStar: true});
		dirs = path.relative(basePath, file).split(path.sep).slice(0, -1);
		var key = basename in apis ? basename + '-s' : basename;
		apis[key] = {
			basename: basename,
			comments: comments,
			dirs: dirs
		};
	});

	return apis;
}

/**
 * generate `index.html`
 * @param  {String} oPath destination path for documentation
 * @param  {String} tPath template path
 * @param  {Object} pkg   object used by jade for rendering
 */
function buildReadme(oPath, tPath, pkg) {
	pkg.doc = {
		name: 'readme',
		content: pkg.readme
	};
	var html = jade.renderFile(path.join(tPath, 'index.jade'), pkg);
	fs.writeFileSync(path.join(oPath, 'index.html'), html, 'utf8');
}

/**
 * build `.html` per `.md`
 * @param  {String} oPath destination path for documentation
 * @param  {String} tPath template path
 * @param  {Object} pkg   object used by jade for rendering
 */
function buildDocs(oPath, tPath, pkg) {
	var html;
	for (doc in pkg.docs) {
		pkg.doc = {
			name: doc,
			content: pkg.docs[doc]
		};
		html = jade.renderFile(path.join(tPath, 'doc.jade'), pkg);
		fs.writeFileSync(path.join(oPath, doc + '.html'), html, 'utf8');
	}
}

/**
 * build `api.html`
 * @param  {String} oPath destination path for documentation
 * @param  {String} tPath template path
 * @param  {Object} pkg   object used by jade for rendering
 */
function buildApis(oPath, tPath, pkg) {
	var html;
	html = jade.renderFile(path.join(tPath, 'api.jade'), pkg);
	fs.writeFileSync(path.join(oPath, 'api.html'), html, 'utf8');
}

/**
 * copy assets to destination path
 * @param  {String} src  source path to copy from
 * @param  {String} dest destination path to copy to
 */
function copyAssets(src, dest) {
	ncp(src, dest, function (err) {
		if (err) {
			return console.error(err);
		}
	});
}

/**
 * copy file to destination
 * @param  {String} src  source file to copy from
 * @param  {String} dest destination file to copy to
 */
function copyFile(src, dest) {
	var newFile = fs.createWriteStream(dest),
		oldFile = fs.createReadStream(src);

	oldFile.pipe(newFile);
}

/**
 * entry point of the program
 * @param  {String} input where source js live
 * @param  {String} output where generated documents live
 * @param  {Array} exclude list of paths where documents should not be generated
 * @param  {String} css path to an extra css file to include (optional)
 */
function process (input, output, exclude, css) {
	var pwd = path.resolve('.');
	// where generated documents live
	var oPath = prepareOutputPath(output);
	// where source js live
	var iPath = input ? path.resolve(pwd, input) : pwd;
	// where templates live
	var tPath = path.resolve(__dirname, '../templates');
	// directories to be excluded
	var ePath = exclude ? exclude.split(/\s*,\s*/) : [];
	// optional css file to include
	var cssFile = css ? path.join('assets/custom', path.basename(css)) : null;

	// retrieve package
	var pkg = getPackage(pwd);
	if (!pkg) {
		return false;
	}

	pkg.readme = getReadme(pwd);
	pkg.docs = getDocs(pwd);
	var files = [];
	walk(iPath, ePath, files); // find all js files under the path recursively
	pkg.apis = getApis(pwd, files);
	pkg.css = cssFile;

	// generates documents
	buildReadme(oPath, tPath, pkg);
	buildDocs(oPath, tPath, pkg);
	buildApis(oPath, tPath, pkg);

	// copy assets to destination folder
	copyAssets(path.join(tPath, '/assets'), path.join(oPath, '/assets'));
	if (cssFile) {
		copyFile(path.resolve(css), path.join(oPath, cssFile));
	}
}
